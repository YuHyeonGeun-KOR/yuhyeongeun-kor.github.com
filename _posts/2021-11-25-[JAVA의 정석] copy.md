---
title:  "객체 지향 프로그래밍 3"
excerpt: "객체지향 프로그래밍에 대하여"
categories:
  - Java
tags:
  - [JAVA, JAVA의 정석]

toc: true
toc_sticky: true
 
date: 2021-12-01
last_modified_at: 2021-12-01
---

# 단일상속
- 여러 조상 클래스부터 상속받는 것이 가능한 다중상속을 자바에서는 허용하지 않는다. 
- 자바는 오직 단일 상속만을 허용한다. 
- 왜?? 복합적인 기능을 가진 클래스를 쉽게 작성할 수 있다는 장점이 있지만 상속받은 멤버간의 이름이 같으면 구별하기 어렵기 때문이다. 
- 이름을 다르게 지어주면 되긴 하지만 그러면 해당 매소드를 사용하는 모든 클래스를 변경해주어야 하기 때문에 간단한 문제가 아니다
- 다른 클래스를 포함 시키기 위해서 클래스 내에 인스턴스를 생성해서 매소드를 인스터느에서 호출하여 사용한다. 

# 오버라이딩
- 상속받은 메서드의 내용을 변경하는 것을 말한다. 

오버라이딩의 조건  
1. 이름이 같아야 한다. 
2. 매개변수가 같아야 한다. 
3. 반환타입이 같아야 한다. 
4. 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다. 
5. 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다. 
6. 인스턴스메서드를 static메서드로 또는 그 반대로 변경할 수 없다. 


# super 
- 자손 클래스에서 조상클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수
- 언제 사용? : 조상클래스의 멤버와 자손 클래스의 멤버가 종복정의되어 서로 구별해얃 하는 경우에만 사용하는 것이 좋다. 
- super() : 조상 클래스의 생성자   
ex) print3D p3 = new Print3D(); 를 인스턴스 하면
Prind3D() -> Print3D(int x , int y , int z) -> Print3D(int x, int y) -> object()

# 패키지 
- 클래스가 물리적으로 하나의 클래스 파일인것같이 하나의 디렉토리다. 
- 패키지명은 대소문자를 허용하지만 클래스명과 비교되기 위해 소문자를 사용한다. 

# 접근 제어자를 이용한 캡슐화
- 클래스의 내부의 선언된 데이터를 보호하기 위해서
- 데이터 감추기 , 객체지향개념의 캡슐화 
- 외부에서는 불필요하고 내부적으로만 사용되는 동작을 감출때 

***생성사의 접근 제어자***
- 생성자의 접근 제어자를 pricate으로 지정하면 외부에서 생성자에 접근할 수 없으믈 인스턴스를 생성할 수 없게 된다. 
- 생성자가 Private라면 다른 클래스의 조상이 될 수 없다. 
- 이유? : 자식 클래스가 인스턴스를 생성할 때 조상 클래스의 생성자를 호출해야만 한다. --> 따라서 클래스 명칭 앞에 final을 붙혀 상속할 수 없는 클래스라는 것을 명시해준다. 

# 제어자의 조합
조합시 유의사항
1. 메서드에 static과 absreact를 함께 사용 불가 : static은 몸통이 있는 메서드에만 사용 가능 
2. 클래스에 abstract 와 final을 동시에 사용할 수 없다. : 클래스에 사용되는 final은 클래스를 확장할 수 없다는 의미이고 abstract는 상속을 통해 완성 되기 때문에 모순이다. 
3. abstract 메서드의 접근 제어자가 priavate일 수 없다. :
abstract 메서드는 자손 클래스에서 두현해중어야 하는데 private면 접근이 불가하다. 
4. 메서드에 private와 final을 같이 사용할 필요는 없다. : 
접근자가 private면 오버라이딩이 불가 하기 때문에 final이 없어도 같은 제한을 요한다. 둘중 하나만 사용하면 된다. 


# 다형성 
- 여러가지 형태를 가질 수 있는 능력 
- 조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 한다. 
- 하지만 같은 타입의 인스턴스지만 참조변수의 타입에 따라 사용할 수 있는 멤버의 개수가 달라진다. 

***참조변수의 형변환***
- 자손타입 -> 조상타입(업캐스팅) : 형병환 생략가능
- 조상타입 -> 자손타입(다운캐스팅) : 형변환 생략불가

# 추상 클래스 
- 미완성 메서드를 포함하고 있다. 
- 만약 같은 크기의 tv라도 기능의 차이에 따라 모델은 여러가지지만 이들의 설계도의 90%는 동일하다고 할때, 공통부분을 포함하는 미완성 설계도를 가지고 나머지는 구성하는 것이 효율적이다. 
- 미완성 상태로 두는 이유 : 상속받는 클래스에 따라 달라질 수 있기 때문에 조상 크래스에서 선언부만 작서하고 주석으로 수행할 목적을 명시하고 내용은 상속받는 클래스에서 구현하도록 비워둔다.  
***중요한 부분***
- 구현부 보다 더 중요한 부분 : 선언부 
- 메서드의 이름, 작업에 필요한 매개변수, 결과로 어떤 타입의 값을 반환할 것인가를 결정하는 건은 쉽지 않다 
- 선언부만 작성해보 절반 이상이 완성된 것이라 해도 과언이 아니다. 


