---
title:  "프로그래머스 : 여행경로"
excerpt: 알고리즘

categories:
  - 프로그래머스
tags:
  - [code,Python,BFS/DFS]

toc: true
toc_sticky: true
 
date: 2021-09-28
last_modified_at: 2020-09-28
---

# 문제

![](/yuhyeongeun-kor.github.com/assets/images/09-28-09-95.png)

## 접근법
이 문제는 모든 항공권을 사용하여 ICN에서 출발하는 모든 경로를 출력하는 문제입니다.
처음에 이 문제를 접근 했던 방법은 아래와 같습니다.
### 잘못된 접근
 해당 경로들의 이름을 숫자로 매칭하여 dic으로 선언된 각 공항의 이름을 통하여 해당 공항에서 출발할 수 있는 도착지 중에서 알파벳 순 기준으로 우선적인 공항을 경로에 추가해주고 만약 더이상 방문할 수 있는 공항이 없을 때에는 경로를 마치고 종료한다.

위와 같은 접근접으로 했을 때에는 문제가 생깁니다.
아래의 예제와 같을 때의 경로를 생각해보았습니다.
```
 [["ICN", "B"], ["B", "ICN"], ["ICN", "A"], ["A", "D"], ["D", "A"]]
```
 위와 같다면 저의 코드에서는 아래와 같이 정렬되고 저장될 것입니다.
```
 [{ICN : A,B} , {B : ICN} , {A : D} , {D : A}]
```
 위의 정보를 기반으로 처음의 접근법으로 진행 했을 때의 경로는 다음과 같습니다.
 ```
 {ICN , A ,D, A }
 ```
 왜냐하면 알파벳 순으로 우선적으로 경로를 구성한 것은 맞지만 문제에서 "모든 항공권을 사용하여" 라고 명시 되어 있기 떄문에 해당 접근 법은 잘못되었다는 것을 알게 되었습니다.


 그렇다면 어떻게 접근 해야 할까???

## 올바른 접근법
위의 처럼 정렬하여 항공편을 저장하는 것은 동일 하다.
하지만 위의 경로를 진행할 스택에 넣기는 하지만 할 때마다 해당 경로를 빼서 사용하는 것이 아닌 스택에 있는대로 제일 마지막에 들어온 것을 사용한다.
다음과 같이 사용한 이유는 아래과 같다.

위의 예시를 사용했을 때 스택의 쌓이는 데이터과 경로에 추가되는 모습을 확인해보면 알 수 있다.
```
[ ICN ] 
```
처음에 경로는 ICN으로 시작하므로 해당 공항에서 출발할 수 있는 경로를 확인한다.
```
 A,B
```
따라서 위에 알파벳 기준에서는 A를 추가하려고 할 때 추가적인 조건이 필요하다.
A에서 출발 할 수 있는지를 확인해야 한다.
만약 A에서 도착할 수 있는 경로가 있다면 도착지를 스택에 추가한다.
이렇게 해주는 이유는 만약에 도착할 수 있는 경로가 없다는 것은 다른 공항에 도착할 곳이 없다는 것이고 이는 마지막 경로이거나 이전 경로에서 이미 사용되었다는 것이다.

이때는 도착할 수 있는 곳이 있으므로 다음과 같이 된다.
```
[ICN, A]
[ICN, A , D ]
```
그런데 이때 우리는 스택에 추가 할때마다 저장되어 있는 리스트에서 사용된 경로를 제거하므로 남아있는 경로와 스택을 확인해보면
```
스택 : [ICN A , D, A]

[{ICN : B} , {B : ICN} , {A : } , {D : }]
```
다음과 같이 된다. 

이때 스택에 마지막에 있는 공항에서 도착할 수 있는 경로가 없을 때 해당 공항을 정답 리스트에 추가한다.
```
[A]
```
위와 같이 도착지가 없는 공항은 정답리스트에 넘기고 도착지가 있는 공항은 다시 참조스택에 넣어주면 된다. 다시 도착지가 있기 전까지의 과정까지 진행하면 다음과 같다.

```
스택 : [ICN]
정답 : [A , D , A]
{ICN : B} , {B : ICN} , {A : } , {D : }]
```
이 때 다시 스택에서 확인 했을 때에 B에 도착할 수 있으므로 다시 스택에 추가해주고 다음과정에서 B에서는 ICN에 도착할 수 있으므로 다시 추가 되어진다.

다음과정에서 ICN에서 더이상 갈 수 없으므로 스택에 있는 것을 정답리스트에 차례대로 추가해주면 

```
[A , D , A , ICN , B , ICN]
````

위의 리스트를 뒤집어 주면 원래 의도대로의 경로가 나오게 된다.

## 결론 

이렇게 풀기 위해서 생각했던것은 일단 구성되어 질 수 있는 경로는 구성하고 만약 더이상 구성할 수 없을 때에는 해당 경로는 더이상 쓸 수 없는 경로 이기 때문에 정답리스트에 일단 추가해 놓고 다시 도착할 수 있는 공항이 있을 때는 이미 이전 경로가 알파벳 순으로 처리 되었거나 처음으로 추가되는 경로 이므로 다시 경로에 추가해주고 과정을 반복해 준 다음 경로를 반대로 출력해주면 된다. 


``` python
from collections import deque
def solution(tickets):
    answer = []
    airport = {}
    start_queue = deque()
    
    for ticket in tickets:
        airport[ticket[0]] =[]
    
    for ticket in tickets:
        airport[ticket[0]].append(ticket[1])
    
    start_queue.append("ICN")
    
    for i,j in airport.items():
        airport[i]  = sorted(airport[i] , reverse=True)
    print(airport)

    while start_queue:
        start = start_queue[-1]
        if start in airport and airport[start]:
            start_queue.append(airport[start].pop())    
        else:
            answer.append(start_queue.pop())

    
    answer.reverse()
    return answer
```