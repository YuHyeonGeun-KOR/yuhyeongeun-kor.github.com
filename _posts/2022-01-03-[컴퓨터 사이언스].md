---
title: 프로세와 쓰레드
excerpt: "프로세스와 스케쥴러의 이해 , 프로세스간 커뮤니케이션"
categories:
  - CS
tags:
  - [CS, 운영체제]

toc: true
toc_sticky: true
 
date: 2021-12-17
last_modified_at: 2021-12-17
---

# 프로세스와 컨텍스트 스위칭 
## Context switching 
- CPU에 실행할 프로세스를 교체하는 기술 
- 스위칭 방법
  + 실행 중지할 프로세스 정보를 해당 프로세스의 PCB에 업데이트 후 메인메모리에 저장 
  + 다음 실행할 프로세스 정보를 메인 메모리에 있는 해당 PB정보를 CPU 레지스터에 넣고 실행 

***컨텍스트 스위칭 시간을 줄이기 위해서 어셈블리어로 컨테스트 스위킹 코드를 작성하면 속도는 빠르지만 새로운 cpu 아키텍쳐가 나올 떄마다 프로그램을 새로 작성해줘야 한다. 하지만 컴파일러의 등장으로 컴파일러 프로그램만 만들면 되기 때문에 재작성 할 필요가 없어지고 속도는 어셈블리 코드보다는 떨어지지만 이식성이 매우 높다.***



# 프로세스간 커뮤니케이션
- 프로세스들이 서로의 공간을 접근하면 프로세스 코드가 바뀔 수 있어 매우 위험하다. 
- 따라서 프로세스는 다른 프로세스의 공간을 접근할 수 없다. 

## 그럼 어떻게 서로 커뮤니케이션을 할까?
- 프로세스간 통신방법을 제공 
- IPC : InterProcess Communication

### fork()
- 프로세스 자신을 복사해서 새로운 프로세스를 만드는 시스템 콜 
- 여러 프로세스를 동시에 실행 시킬 수 있다. 
- 만약 프로레슷 10개를 만들어서 그 결과를 한나로 수집해야 한다면 각각 프로세스가 서로 통신을 통해 수집할 수 있어야 한다.  
ex) 웹서버에서 새로운 사용자 욫어이 올 때마다 fork()함수로 새로운 프로세스를 만들고 그에 대한 대응을 한다. 

### 그럼 어떻게 통신하려고 할까?
- file을 사용하는 방법이 있다. file을 하나 만들어서 다른 프로세스에 전달할 내용을 파일에 쓰고 다른 프로세스가 그 파일을 읽어서 가져오면된다. 
- 하지만 file을 사용하게 되면실시간으로 원하는 데이터 전다리 어렵고 너무 오래걸린다. 

--> 공유공간을 이용한다. 
- 프로세스는 약 4GB정도의 공간을 할당할 수 있다.
- 이중에서 4~3GB는 운영체제를 위한 커널 공간이고 나머지는 사용자 공간이다. 
- 그런데 프로세스가 생성될 때 마다 이런 커널 공간을 만들면 배우 비효율적이다. 커널 공간은 사용자 모드에서 직접적으로 접근이 불가하기 떄문에 이러한 공간을 프로세스가 공유하는 방식으로 통신한다. 


## 다양한 IPC 기법
- file
- Message Queue
- Shared Memory
- Pipe
- Signal
- Semaphore
- Socket

위의 예시중 2번쨰 부터의 방법은 커널 공간을 사용하여 통신한다. 


# PIPE 
- 파이프는 단방향 통신을 지원한다. 
- fork()로 자식 프로세스를 만들었을 떄 부모와 자식간에 단방향 통신을 한다. 
- 프로세스 아이디와 fd를 활용한다.
![](/yuhyeongeun-kor.github.com/assets/images/12-16-12-97.png)

# 메시지 큐
- FIFO 정책으로 데이터를 전송한다. 
- 메세지 큐에 큐아이디를 통해 생성한다. 
- 부모자식간 통신이 아니라 어느 프로세스간에라도 데이터 송수신이 가능하고 양뱡항 통신이 가능하다. 

# 시그널
- 커널 또는 프로세스에서 다른 프로세스에 이벤트가 발생했다고 알려주는 기법
- 사용자 모드에서 커널 모드로 변경시키고 사기 사용자 모드로 전환되는 시점에 해당 프로세스 pcb에 시그널을 처리한다. 만약 사용자모드에서 실행되어야 하는 함수가 있다면 사용자 모드로 넘어가서 처리한다. 

# 소켓
- 소켓은 네트워크 통신을 위한 기술이다. 
- 하나의 컴퓨터에서 프로세스간에 통신으로 할떄 프로세스가 커널영역의 여러 계층을 통해서 네트워크 디바이스로 전달하고 해당 디바에스로 그 정보를 전달해서 다른 프로세스와 통신하는 방법이다.



# 정리 
- 컴파일을 통해 실행파일을 생성한다. 
- 실행파일을 사용하기 위해서 shell과 같은 사용자 인터페이스를 사용한다. 
- 해당 프로세스가 생성되면 read상태가 되고 스케쥴러 정책에 따라 인터럽트를 통해 프로세스 상태를 변경한다. 
- 이때 pcb 정보를 메인메모리에 저장하고 지금 실행할 프로세스의 pcb정보를 메인메모리에서 읽어와서 실행한다. 
- 이떄 인터럽트는 IDT를 참고하고 이는 os가 부팅될떄 만들어지고 IDT에서 해당 시스템콜 함수를 찾고 실행하여 커널영역에서 처리하고 사용잠 모드로 전환한다. 

